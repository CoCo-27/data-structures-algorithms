Majority of the times these are all the data structures and algorithms you will need to answer most questions:

Data structures:

    * Arrays
    * Stacks
    * Queues
    * Linked lists
    * Trees
    * Tries
    * Graphs
    * Hash tables

Algorithms:

    * Sorting
    * Dynamic programming
    * Breadth first and Depth first search
    * Recursion

---

Heurestics for solving problems:

    * Hash Maps are usually the answer to improve Time Complexity
    * If it's a sorted array, use Binary tree to achieve O(log N). Divide and Conquer - Divide a data set
      into smaller chunks and then repeating a process with a subset of data. Binary search is a great example of this
    * Try Sorting your input
    * Hash tables and precomputed information (i.e. sorted) are some of the best ways to optimize your code
    * Look at the Time vs Space tradeoff. Sometimes storing extra state in memory can help the time.
    * If the interviewer is giving you advice/tips/hints. Follow them
    * Space time tradeoffs: Hastables usually solve this a lot of the times. You use more space, but you
      can get a time optimization to the process. In programming, you often times can use up a little bit
      more space to get faster time

---

Pointers:

    * Simply a reference to something in memory:

        const obj1 = { a: 'hey' };
        const obj2 = obj1;

        both of these vars point to the 1 object that exists in memory. But doing:

            delete obj1;

        doesn't get rid of { a: 'hey' }, since it's still being referenced by obj2. If ob2's value is changed to something else:

            obj2 = 'is now a string';

        at this point { a: 'hey' } is erased from memory by JavaScript's automatic garbage collection since it's not in use anywhere

    * In lower level languages where you have to manage your own memory, you need to delete pointers that aren't needed anymore in order
      to free up resources

---

Arrays (aka "Lists"):

    We know the index:

        Lookups     - O(1)

    After insert or delete the rest of the items need to be shifted/their place updated:

        Insert      - O(n)
        Delete      - O(n)

    It's at the end so no other val needs to be updated:

        Append      - O(1)

    2 types of arrays:

        1. Static arrays    - you define how many items an array will hold when making the array, low level languages like C has these
        2. Dynamic arrays   - high level languages like JavaScript and Python uses these, automatically allocates space in memory (i.e. expands) based on value length

    Notes
        * Treat string problems as array problems, most can be solved using arrays
        * Arrays are great for storing sorted data and therefore to use in sorting problems

    Pros:
        * Fast Lookups
        * Fast push/pop
        * Storing ordered data
    
    Cons:
        * Slow inserts
        * Slow deletes
        * Fixed size (if using static arrays)

---

Hash Tables (aka "Dictionaries"):


    The computer takes the key and runs it through a hash function which converts it to a 
    memory address so that next time it knows where to access the data. Hash functions (e.g. MD5) always
    returns the same output given the same input

    Since Hash Tables don't preserve order if you delete a key theres no need to shift all the other values unlike arrays
    hence all these operations are O(1):

        Insert      - O(n)
        Lookups     - O(1)
        Delete      - O(n)
        Search      - O(1)

    Above are best case scenerios, in the worst case scenerio all these can be O(n) due to collisions.
    Collisions are unavoidable in a large enough data set given the limited availability of memory space. There are ways 
    the launguage handles collisions under the hood like storing all data at a given adddress in a linked lists for example. 
    In this case a lookup is an O(n) operation since the computer needs to traverse this list to find the value it's looking for


    Map()
        - allows any data type as keys (e.g. numbers, functions, etc) vs objects that only allow strings
        - maintains insertion order

    Set()
        - unlike maps and objects sets can only hold 1 item in a slot (like an array)
        - the difference between a set and an array is that all values in a set are unique whereas an array can hold multiple duplicate values
        - maintains insertion order (?)

    WeakMap()
        - (?)

---

Linked Lists:

    Better than arrays in the sense that you don't have to shift/unshift all other values after inserting or deleting nodes, just have to update some pointers
    One advantage arrays have over linked lists is that you can access values in O(1) by index, in a LL you have to traverse form the head down until you find what 
    you're looking for so LL are better for insert/delete operations but worse for read when compared to arrays

    Prepend     - O(1)
    Append      - O(1)

    Lookups     - O(n)
    Insert      - O(n)
    Delete      - O(n)

    ** last three are O(n) because they all require traversal

    Doubly linked lists:
        - these have pointers to the next node AND the one before, otherwise it's exactly the same with singly LL
        - unlike singly linked lists these can also be traversed backwards


